//! Azure semantic conventions
//!
//! This module provides semantic convention attributes for Azure services instrumentation.
//! Based on OpenTelemetry Azure semantic conventions.

const std = @import("std");
const types = @import("../types.zig");

/// Azure Client SDK attributes
pub const ClientSdkAttributes = struct {
    /// The unique identifier of the service request.
    pub const service_request_id = types.StringAttribute.init(
        "azure.service.request.id",
        "The unique identifier of the service request. It's generated by the Azure service and returned with the response.",
        .experimental,
        .recommended,
    ).withExamples(&[_][]const u8{"00000000-0000-0000-0000-000000000000"});

    /// Azure Resource Provider Namespace as recognized by the client.
    pub const resource_provider_namespace = types.StringAttribute.init(
        "azure.resource_provider.namespace",
        "Azure Resource Provider Namespace as recognized by the client.",
        .experimental,
        .recommended,
    ).withExamples(&[_][]const u8{ "Microsoft.Storage", "Microsoft.KeyVault", "Microsoft.ServiceBus" });

    /// The unique identifier of the client instance.
    pub const client_id = types.StringAttribute.init(
        "azure.client.id",
        "The unique identifier of the client instance.",
        .experimental,
        .recommended,
    ).withExamples(&[_][]const u8{ "3ba4827d-4422-483f-b59f-85b74211c11d", "storage-client-1" });
};

/// Azure Cosmos DB attributes
pub const CosmosDbAttributes = struct {
    /// Cosmos client connection mode.
    pub const connection_mode = types.EnumAttribute.init(
        "azure.cosmosdb.connection.mode",
        "Cosmos client connection mode.",
        .experimental,
        .recommended,
    ).withMembers(&[_]types.EnumMember{
        .{ .value = "gateway", .brief = "Gateway (HTTP) connection.", .stability = .experimental },
        .{ .value = "direct", .brief = "Direct connection.", .stability = .experimental },
    });

    /// The number of request units consumed by the operation.
    pub const operation_request_charge = types.DoubleAttribute.init(
        "azure.cosmosdb.operation.request_charge",
        "The number of request units consumed by the operation.",
        .experimental,
        .recommended,
    ).withExamples(&[_]f64{1.0});

    /// List of regions contacted during the operation.
    pub const regions_contacted = types.ArrayAttribute.init(
        "azure.cosmosdb.regions_contacted",
        .string,
        "List of regions contacted during the operation. If there is more than one region listed, it indicates that the operation was performed on multiple regions i.e. cross-regional call.",
        .experimental,
        .recommended,
    ).withExamples(&[_][]const u8{ "North Central US", "Australia East", "Australia Southeast" })
        .withNote("Region name matches the format of `displayName` in Azure Location API");

    /// Cosmos DB sub status code.
    pub const response_sub_status_code = types.IntAttribute.init(
        "azure.cosmosdb.response.sub_status_code",
        "Cosmos DB sub status code.",
        .experimental,
        .recommended,
    ).withExamples(&[_]i64{ 1000, 1002 });

    /// Cosmos DB consistency level.
    pub const consistency_level = types.EnumAttribute.init(
        "azure.cosmosdb.consistency.level",
        "Cosmos DB consistency level.",
        .experimental,
        .recommended,
    ).withMembers(&[_]types.EnumMember{
        .{ .value = "Strong", .brief = "Strong", .stability = .experimental },
        .{ .value = "BoundedStaleness", .brief = "Bounded Staleness", .stability = .experimental },
        .{ .value = "Session", .brief = "Session", .stability = .experimental },
        .{ .value = "Eventual", .brief = "Eventual", .stability = .experimental },
        .{ .value = "ConsistentPrefix", .brief = "Consistent Prefix", .stability = .experimental },
    }).withExamples(&[_][]const u8{ "Eventual", "ConsistentPrefix", "BoundedStaleness", "Strong", "Session" });
};

/// Helper functions for Azure operations
pub const AzureUtils = struct {
    /// Check if a resource provider namespace is valid
    pub fn isValidResourceProvider(namespace: []const u8) bool {
        return std.mem.startsWith(u8, namespace, "Microsoft.") or
            std.mem.startsWith(u8, namespace, "microsoft.") or
            std.mem.indexOf(u8, namespace, ".") != null;
    }

    /// Extract service name from resource provider namespace
    pub fn extractServiceFromResourceProvider(namespace: []const u8) ?[]const u8 {
        if (std.mem.indexOf(u8, namespace, ".")) |dot_idx| {
            if (dot_idx + 1 < namespace.len) {
                return namespace[dot_idx + 1 ..];
            }
        }
        return null;
    }

    /// Check if Azure service request ID is valid UUID format
    pub fn isValidServiceRequestId(request_id: []const u8) bool {
        // Basic UUID format check: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
        if (request_id.len != 36) return false;

        const dash_positions = [_]usize{ 8, 13, 18, 23 };
        for (dash_positions) |pos| {
            if (request_id[pos] != '-') return false;
        }

        for (request_id, 0..) |c, i| {
            const is_dash_pos = for (dash_positions) |pos| {
                if (i == pos) break true;
            } else false;

            if (!is_dash_pos and !std.ascii.isHex(c)) {
                return false;
            }
        }

        return true;
    }

    /// Get recommended consistency level based on operation type
    pub fn getRecommendedConsistencyLevel(operation_type: []const u8, read_heavy: bool) []const u8 {
        if (std.mem.eql(u8, operation_type, "write") or std.mem.eql(u8, operation_type, "update")) {
            return "Session"; // Good balance for write operations
        } else if (read_heavy) {
            return "Eventual"; // Better performance for read-heavy workloads
        } else {
            return "Session"; // Default balanced option
        }
    }
};

// Tests
test "Azure resource provider validation" {
    const testing = std.testing;

    try testing.expect(AzureUtils.isValidResourceProvider("Microsoft.Storage"));
    try testing.expect(AzureUtils.isValidResourceProvider("Microsoft.KeyVault"));
    try testing.expect(!AzureUtils.isValidResourceProvider("InvalidProvider"));

    try testing.expectEqualStrings("Storage", AzureUtils.extractServiceFromResourceProvider("Microsoft.Storage").?);
    try testing.expectEqualStrings("KeyVault", AzureUtils.extractServiceFromResourceProvider("Microsoft.KeyVault").?);
}

test "Azure service request ID validation" {
    const testing = std.testing;

    try testing.expect(AzureUtils.isValidServiceRequestId("00000000-0000-0000-0000-000000000000"));
    try testing.expect(AzureUtils.isValidServiceRequestId("3ba4827d-4422-483f-b59f-85b74211c11d"));
    try testing.expect(!AzureUtils.isValidServiceRequestId("invalid-uuid"));
    try testing.expect(!AzureUtils.isValidServiceRequestId("3ba4827d-4422-483f-b59f-85b74211c11"));
}

test "consistency level recommendations" {
    const testing = std.testing;

    try testing.expectEqualStrings("Session", AzureUtils.getRecommendedConsistencyLevel("write", false));
    try testing.expectEqualStrings("Eventual", AzureUtils.getRecommendedConsistencyLevel("read", true));
    try testing.expectEqualStrings("Session", AzureUtils.getRecommendedConsistencyLevel("read", false));
}

test "Azure attribute definitions" {
    const testing = std.testing;

    try testing.expectEqualStrings("azure.service.request.id", ClientSdkAttributes.service_request_id.name);
    try testing.expectEqualStrings("azure.cosmosdb.connection.mode", CosmosDbAttributes.connection_mode.base.name);
}
